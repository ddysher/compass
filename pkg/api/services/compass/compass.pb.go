// Code generated by protoc-gen-go.
// source: compass.proto
// DO NOT EDIT!

/*
Package compass is a generated protocol buffer package.

It is generated from these files:
	compass.proto

It has these top-level messages:
	Status
	Info
	Release
	CreateReleaseRequest
	CreateReleaseResponse
	UpdateReleaseRequest
	UpdateReleaseResponse
	UpgradeReleaseRequest
	UpgradeReleaseResponse
	ListReleasesRequest
	ListSort
	ListReleasesResponse
	GetReleaseStatusRequest
	GetReleaseStatusResponse
	GetReleaseContentRequest
	GetReleaseContentResponse
	RollbackReleaseRequest
	RollbackReleaseResponse
	DeleteReleaseRequest
	DeleteReleaseResponse
	GetReleaseHistoryRequest
	GetReleaseHistoryResponse
	TestReleaseRequest
	TestReleaseResponse
*/
package compass

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import hapi_release "k8s.io/helm/pkg/proto/hapi/release"
import hapi_chart "k8s.io/helm/pkg/proto/hapi/chart"
import _ "google.golang.org/genproto/googleapis/api/annotations"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// SortBy defines sort operations.
type ListSort_SortBy int32

const (
	ListSort_UNKNOWN       ListSort_SortBy = 0
	ListSort_NAME          ListSort_SortBy = 1
	ListSort_LAST_RELEASED ListSort_SortBy = 2
)

var ListSort_SortBy_name = map[int32]string{
	0: "UNKNOWN",
	1: "NAME",
	2: "LAST_RELEASED",
}
var ListSort_SortBy_value = map[string]int32{
	"UNKNOWN":       0,
	"NAME":          1,
	"LAST_RELEASED": 2,
}

func (x ListSort_SortBy) String() string {
	return proto.EnumName(ListSort_SortBy_name, int32(x))
}
func (ListSort_SortBy) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 0} }

// SortOrder defines sort orders to augment sorting operations.
type ListSort_SortOrder int32

const (
	ListSort_ASC  ListSort_SortOrder = 0
	ListSort_DESC ListSort_SortOrder = 1
)

var ListSort_SortOrder_name = map[int32]string{
	0: "ASC",
	1: "DESC",
}
var ListSort_SortOrder_value = map[string]int32{
	"ASC":  0,
	"DESC": 1,
}

func (x ListSort_SortOrder) String() string {
	return proto.EnumName(ListSort_SortOrder_name, int32(x))
}
func (ListSort_SortOrder) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 1} }

type Status struct {
	Code             int32                   `protobuf:"varint,1,opt,name=code" json:"code,omitempty"`
	Resources        string                  `protobuf:"bytes,2,opt,name=resources" json:"resources,omitempty"`
	Notes            string                  `protobuf:"bytes,3,opt,name=notes" json:"notes,omitempty"`
	LastTestSuiteRun *hapi_release.TestSuite `protobuf:"bytes,4,opt,name=last_test_suite_run,json=lastTestSuiteRun" json:"last_test_suite_run,omitempty"`
}

func (m *Status) Reset()                    { *m = Status{} }
func (m *Status) String() string            { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()               {}
func (*Status) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Status) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *Status) GetResources() string {
	if m != nil {
		return m.Resources
	}
	return ""
}

func (m *Status) GetNotes() string {
	if m != nil {
		return m.Notes
	}
	return ""
}

func (m *Status) GetLastTestSuiteRun() *hapi_release.TestSuite {
	if m != nil {
		return m.LastTestSuiteRun
	}
	return nil
}

type Info struct {
	Status        *Status `protobuf:"bytes,1,opt,name=status" json:"status,omitempty"`
	FirstDeployed int64   `protobuf:"varint,2,opt,name=first_deployed,json=firstDeployed" json:"first_deployed,string,omitempty"`
	LastDeployed  int64   `protobuf:"varint,3,opt,name=last_deployed,json=lastDeployed" json:"last_deployed,string,omitempty"`
	Deleted       int64   `protobuf:"varint,4,opt,name=deleted" json:"deleted,string,omitempty"`
	Description   string  `protobuf:"bytes,5,opt,name=Description" json:"Description,omitempty"`
}

func (m *Info) Reset()                    { *m = Info{} }
func (m *Info) String() string            { return proto.CompactTextString(m) }
func (*Info) ProtoMessage()               {}
func (*Info) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Info) GetStatus() *Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Info) GetFirstDeployed() int64 {
	if m != nil {
		return m.FirstDeployed
	}
	return 0
}

func (m *Info) GetLastDeployed() int64 {
	if m != nil {
		return m.LastDeployed
	}
	return 0
}

func (m *Info) GetDeleted() int64 {
	if m != nil {
		return m.Deleted
	}
	return 0
}

func (m *Info) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type Release struct {
	Name      string             `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Info      *Info              `protobuf:"bytes,2,opt,name=info" json:"info,omitempty"`
	Chart     *hapi_chart.Chart  `protobuf:"bytes,3,opt,name=chart" json:"chart,omitempty"`
	Config    *hapi_chart.Config `protobuf:"bytes,4,opt,name=config" json:"config,omitempty"`
	Version   int32              `protobuf:"varint,5,opt,name=version" json:"version,omitempty"`
	Namespace string             `protobuf:"bytes,6,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *Release) Reset()                    { *m = Release{} }
func (m *Release) String() string            { return proto.CompactTextString(m) }
func (*Release) ProtoMessage()               {}
func (*Release) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Release) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Release) GetInfo() *Info {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *Release) GetChart() *hapi_chart.Chart {
	if m != nil {
		return m.Chart
	}
	return nil
}

func (m *Release) GetConfig() *hapi_chart.Config {
	if m != nil {
		return m.Config
	}
	return nil
}

func (m *Release) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Release) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

type CreateReleaseRequest struct {
	Chart     string             `protobuf:"bytes,1,opt,name=chart" json:"chart,omitempty"`
	Name      string             `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Namespace string             `protobuf:"bytes,3,opt,name=namespace" json:"namespace,omitempty"`
	Values    *hapi_chart.Config `protobuf:"bytes,4,opt,name=values" json:"values,omitempty"`
	Timeout   int64              `protobuf:"varint,5,opt,name=timeout" json:"timeout,omitempty"`
	Wait      bool               `protobuf:"varint,6,opt,name=wait" json:"wait,omitempty"`
}

func (m *CreateReleaseRequest) Reset()                    { *m = CreateReleaseRequest{} }
func (m *CreateReleaseRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateReleaseRequest) ProtoMessage()               {}
func (*CreateReleaseRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *CreateReleaseRequest) GetChart() string {
	if m != nil {
		return m.Chart
	}
	return ""
}

func (m *CreateReleaseRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateReleaseRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *CreateReleaseRequest) GetValues() *hapi_chart.Config {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *CreateReleaseRequest) GetTimeout() int64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *CreateReleaseRequest) GetWait() bool {
	if m != nil {
		return m.Wait
	}
	return false
}

type CreateReleaseResponse struct {
	Release *Release `protobuf:"bytes,1,opt,name=release" json:"release,omitempty"`
}

func (m *CreateReleaseResponse) Reset()                    { *m = CreateReleaseResponse{} }
func (m *CreateReleaseResponse) String() string            { return proto.CompactTextString(m) }
func (*CreateReleaseResponse) ProtoMessage()               {}
func (*CreateReleaseResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *CreateReleaseResponse) GetRelease() *Release {
	if m != nil {
		return m.Release
	}
	return nil
}

type UpdateReleaseRequest struct {
	Name      string             `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Version   int32              `protobuf:"varint,2,opt,name=version" json:"version,omitempty"`
	Values    *hapi_chart.Config `protobuf:"bytes,3,opt,name=values" json:"values,omitempty"`
	Namespace string             `protobuf:"bytes,4,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *UpdateReleaseRequest) Reset()                    { *m = UpdateReleaseRequest{} }
func (m *UpdateReleaseRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateReleaseRequest) ProtoMessage()               {}
func (*UpdateReleaseRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *UpdateReleaseRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UpdateReleaseRequest) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *UpdateReleaseRequest) GetValues() *hapi_chart.Config {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *UpdateReleaseRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

type UpdateReleaseResponse struct {
	Release *Release `protobuf:"bytes,1,opt,name=release" json:"release,omitempty"`
}

func (m *UpdateReleaseResponse) Reset()                    { *m = UpdateReleaseResponse{} }
func (m *UpdateReleaseResponse) String() string            { return proto.CompactTextString(m) }
func (*UpdateReleaseResponse) ProtoMessage()               {}
func (*UpdateReleaseResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *UpdateReleaseResponse) GetRelease() *Release {
	if m != nil {
		return m.Release
	}
	return nil
}

type UpgradeReleaseRequest struct {
	Chart     string             `protobuf:"bytes,1,opt,name=chart" json:"chart,omitempty"`
	Name      string             `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Values    *hapi_chart.Config `protobuf:"bytes,3,opt,name=values" json:"values,omitempty"`
	Namespace string             `protobuf:"bytes,4,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *UpgradeReleaseRequest) Reset()                    { *m = UpgradeReleaseRequest{} }
func (m *UpgradeReleaseRequest) String() string            { return proto.CompactTextString(m) }
func (*UpgradeReleaseRequest) ProtoMessage()               {}
func (*UpgradeReleaseRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *UpgradeReleaseRequest) GetChart() string {
	if m != nil {
		return m.Chart
	}
	return ""
}

func (m *UpgradeReleaseRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UpgradeReleaseRequest) GetValues() *hapi_chart.Config {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *UpgradeReleaseRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

type UpgradeReleaseResponse struct {
	Release *Release `protobuf:"bytes,1,opt,name=release" json:"release,omitempty"`
}

func (m *UpgradeReleaseResponse) Reset()                    { *m = UpgradeReleaseResponse{} }
func (m *UpgradeReleaseResponse) String() string            { return proto.CompactTextString(m) }
func (*UpgradeReleaseResponse) ProtoMessage()               {}
func (*UpgradeReleaseResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *UpgradeReleaseResponse) GetRelease() *Release {
	if m != nil {
		return m.Release
	}
	return nil
}

// ListReleasesRequest requests a list of releases.
//
// Releases can be retrieved in chunks by setting limit and offset.
//
// Releases can be sorted according to a few pre-determined sort stategies.
type ListReleasesRequest struct {
	// Limit is the maximum number of releases to be returned.
	Limit int64 `protobuf:"varint,1,opt,name=limit" json:"limit,omitempty"`
	// Offset is the last release name that was seen. The next listing
	// operation will start with the name after this one.
	// Example: If list one returns albert, bernie, carl, and sets 'next: dennis'.
	// dennis is the offset. Supplying 'dennis' for the next request should
	// cause the next batch to return a set of results starting with 'dennis'.
	Offset string `protobuf:"bytes,2,opt,name=offset" json:"offset,omitempty"`
	// repeated hapi.release.Status.Code status_codes = 6;
	// Namespace is the filter to select releases only from a specific namespace.
	Namespace string `protobuf:"bytes,3,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *ListReleasesRequest) Reset()                    { *m = ListReleasesRequest{} }
func (m *ListReleasesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListReleasesRequest) ProtoMessage()               {}
func (*ListReleasesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ListReleasesRequest) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ListReleasesRequest) GetOffset() string {
	if m != nil {
		return m.Offset
	}
	return ""
}

func (m *ListReleasesRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// ListSort defines sorting fields on a release list.
type ListSort struct {
}

func (m *ListSort) Reset()                    { *m = ListSort{} }
func (m *ListSort) String() string            { return proto.CompactTextString(m) }
func (*ListSort) ProtoMessage()               {}
func (*ListSort) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

// ListReleasesResponse is a list of releases.
type ListReleasesResponse struct {
	// Count is the expected total number of releases to be returned.
	Count int64 `protobuf:"varint,1,opt,name=count" json:"count,string,omitempty"`
	// Next is the name of the next release. If this is other than an empty
	// string, it means there are more results.
	Next string `protobuf:"bytes,2,opt,name=next" json:"next,omitempty"`
	// Total is the total number of queryable releases.
	Total int64 `protobuf:"varint,3,opt,name=total" json:"total,string,omitempty"`
	// Releases is the list of found release objects.
	// repeated hapi.release.Release releases = 4;
	Releases []*Release `protobuf:"bytes,4,rep,name=releases" json:"releases,omitempty"`
}

func (m *ListReleasesResponse) Reset()                    { *m = ListReleasesResponse{} }
func (m *ListReleasesResponse) String() string            { return proto.CompactTextString(m) }
func (*ListReleasesResponse) ProtoMessage()               {}
func (*ListReleasesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *ListReleasesResponse) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *ListReleasesResponse) GetNext() string {
	if m != nil {
		return m.Next
	}
	return ""
}

func (m *ListReleasesResponse) GetTotal() int64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *ListReleasesResponse) GetReleases() []*Release {
	if m != nil {
		return m.Releases
	}
	return nil
}

// GetReleaseStatusRequest is a request to get the status of a release.
type GetReleaseStatusRequest struct {
	// Name is the name of the release
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Version is the version of the release
	Version int32 `protobuf:"varint,2,opt,name=version" json:"version,omitempty"`
	// just for auth
	Namespace string `protobuf:"bytes,3,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *GetReleaseStatusRequest) Reset()                    { *m = GetReleaseStatusRequest{} }
func (m *GetReleaseStatusRequest) String() string            { return proto.CompactTextString(m) }
func (*GetReleaseStatusRequest) ProtoMessage()               {}
func (*GetReleaseStatusRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *GetReleaseStatusRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetReleaseStatusRequest) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *GetReleaseStatusRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// GetReleaseStatusResponse is the response indicating the status of the named release.
type GetReleaseStatusResponse struct {
	// Name is the name of the release.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Info contains information about the release.
	Info *Info `protobuf:"bytes,2,opt,name=info" json:"info,omitempty"`
	// Namesapce the release was released into
	Namespace string `protobuf:"bytes,3,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *GetReleaseStatusResponse) Reset()                    { *m = GetReleaseStatusResponse{} }
func (m *GetReleaseStatusResponse) String() string            { return proto.CompactTextString(m) }
func (*GetReleaseStatusResponse) ProtoMessage()               {}
func (*GetReleaseStatusResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *GetReleaseStatusResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetReleaseStatusResponse) GetInfo() *Info {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *GetReleaseStatusResponse) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// GetReleaseContentRequest is a request to get the contents of a release.
type GetReleaseContentRequest struct {
	// The name of the release
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Version is the version of the release
	Version int32 `protobuf:"varint,2,opt,name=version" json:"version,omitempty"`
	// just for auth
	Namespace string `protobuf:"bytes,3,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *GetReleaseContentRequest) Reset()                    { *m = GetReleaseContentRequest{} }
func (m *GetReleaseContentRequest) String() string            { return proto.CompactTextString(m) }
func (*GetReleaseContentRequest) ProtoMessage()               {}
func (*GetReleaseContentRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *GetReleaseContentRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetReleaseContentRequest) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *GetReleaseContentRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// GetReleaseContentResponse is a response containing the contents of a release.
type GetReleaseContentResponse struct {
	// The release content
	// hapi.release.Release release = 1;
	Release *Release `protobuf:"bytes,1,opt,name=release" json:"release,omitempty"`
}

func (m *GetReleaseContentResponse) Reset()                    { *m = GetReleaseContentResponse{} }
func (m *GetReleaseContentResponse) String() string            { return proto.CompactTextString(m) }
func (*GetReleaseContentResponse) ProtoMessage()               {}
func (*GetReleaseContentResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *GetReleaseContentResponse) GetRelease() *Release {
	if m != nil {
		return m.Release
	}
	return nil
}

type RollbackReleaseRequest struct {
	// The name of the release
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// dry_run, if true, will run through the release logic but no create
	DryRun bool `protobuf:"varint,2,opt,name=dry_run,json=dryRun" json:"dry_run,omitempty"`
	// DisableHooks causes the server to skip running any hooks for the rollback
	DisableHooks bool `protobuf:"varint,3,opt,name=disable_hooks,json=disableHooks" json:"disable_hooks,omitempty"`
	// Version is the version of the release to deploy.
	Version int32 `protobuf:"varint,4,opt,name=version" json:"version,omitempty"`
	// Performs pods restart for resources if applicable
	Recreate bool `protobuf:"varint,5,opt,name=recreate" json:"recreate,omitempty"`
	// timeout specifies the max amount of time any kubernetes client command can run.
	Timeout int64 `protobuf:"varint,6,opt,name=timeout" json:"timeout,omitempty"`
	// wait, if true, will wait until all Pods, PVCs, and Services are in a ready state
	// before marking the release as successful. It will wait for as long as timeout
	Wait bool `protobuf:"varint,7,opt,name=wait" json:"wait,omitempty"`
	// Force resource update through delete/recreate if needed.
	Force     bool   `protobuf:"varint,8,opt,name=force" json:"force,omitempty"`
	Namespace string `protobuf:"bytes,9,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *RollbackReleaseRequest) Reset()                    { *m = RollbackReleaseRequest{} }
func (m *RollbackReleaseRequest) String() string            { return proto.CompactTextString(m) }
func (*RollbackReleaseRequest) ProtoMessage()               {}
func (*RollbackReleaseRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *RollbackReleaseRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RollbackReleaseRequest) GetDryRun() bool {
	if m != nil {
		return m.DryRun
	}
	return false
}

func (m *RollbackReleaseRequest) GetDisableHooks() bool {
	if m != nil {
		return m.DisableHooks
	}
	return false
}

func (m *RollbackReleaseRequest) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *RollbackReleaseRequest) GetRecreate() bool {
	if m != nil {
		return m.Recreate
	}
	return false
}

func (m *RollbackReleaseRequest) GetTimeout() int64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *RollbackReleaseRequest) GetWait() bool {
	if m != nil {
		return m.Wait
	}
	return false
}

func (m *RollbackReleaseRequest) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

func (m *RollbackReleaseRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// RollbackReleaseResponse is the response to an update request.
type RollbackReleaseResponse struct {
	// hapi.release.Release release = 1;
	Release *Release `protobuf:"bytes,1,opt,name=release" json:"release,omitempty"`
}

func (m *RollbackReleaseResponse) Reset()                    { *m = RollbackReleaseResponse{} }
func (m *RollbackReleaseResponse) String() string            { return proto.CompactTextString(m) }
func (*RollbackReleaseResponse) ProtoMessage()               {}
func (*RollbackReleaseResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *RollbackReleaseResponse) GetRelease() *Release {
	if m != nil {
		return m.Release
	}
	return nil
}

// UninstallReleaseRequest represents a request to uninstall a named release.
type DeleteReleaseRequest struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// DisableHooks causes the server to skip running any hooks for the uninstall.
	DisableHooks bool `protobuf:"varint,2,opt,name=disable_hooks,json=disableHooks" json:"disable_hooks,omitempty"`
	// Purge removes the release from the store and make its name free for later use.
	Purge bool `protobuf:"varint,3,opt,name=purge" json:"purge,omitempty"`
	// timeout specifies the max amount of time any kubernetes client command can run.
	Timeout   int64  `protobuf:"varint,4,opt,name=timeout" json:"timeout,omitempty"`
	Namespace string `protobuf:"bytes,5,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *DeleteReleaseRequest) Reset()                    { *m = DeleteReleaseRequest{} }
func (m *DeleteReleaseRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteReleaseRequest) ProtoMessage()               {}
func (*DeleteReleaseRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *DeleteReleaseRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DeleteReleaseRequest) GetDisableHooks() bool {
	if m != nil {
		return m.DisableHooks
	}
	return false
}

func (m *DeleteReleaseRequest) GetPurge() bool {
	if m != nil {
		return m.Purge
	}
	return false
}

func (m *DeleteReleaseRequest) GetTimeout() int64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *DeleteReleaseRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// UninstallReleaseResponse represents a successful response to an uninstall request.
type DeleteReleaseResponse struct {
	// Release is the release that was marked deleted.
	// hapi.release.Release release = 1;
	Release *Release `protobuf:"bytes,1,opt,name=release" json:"release,omitempty"`
	// Info is an uninstall message
	Info string `protobuf:"bytes,2,opt,name=info" json:"info,omitempty"`
}

func (m *DeleteReleaseResponse) Reset()                    { *m = DeleteReleaseResponse{} }
func (m *DeleteReleaseResponse) String() string            { return proto.CompactTextString(m) }
func (*DeleteReleaseResponse) ProtoMessage()               {}
func (*DeleteReleaseResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *DeleteReleaseResponse) GetRelease() *Release {
	if m != nil {
		return m.Release
	}
	return nil
}

func (m *DeleteReleaseResponse) GetInfo() string {
	if m != nil {
		return m.Info
	}
	return ""
}

// GetHistoryRequest requests a release's history.
type GetReleaseHistoryRequest struct {
	// The name of the release.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The maximum number of releases to include.
	Max       int32  `protobuf:"varint,2,opt,name=max" json:"max,omitempty"`
	Namespace string `protobuf:"bytes,3,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *GetReleaseHistoryRequest) Reset()                    { *m = GetReleaseHistoryRequest{} }
func (m *GetReleaseHistoryRequest) String() string            { return proto.CompactTextString(m) }
func (*GetReleaseHistoryRequest) ProtoMessage()               {}
func (*GetReleaseHistoryRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *GetReleaseHistoryRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetReleaseHistoryRequest) GetMax() int32 {
	if m != nil {
		return m.Max
	}
	return 0
}

func (m *GetReleaseHistoryRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// GetHistoryResponse is received in response to a GetHistory rpc.
type GetReleaseHistoryResponse struct {
	// repeated hapi.release.Release releases = 1;
	Releases []*Release `protobuf:"bytes,1,rep,name=releases" json:"releases,omitempty"`
}

func (m *GetReleaseHistoryResponse) Reset()                    { *m = GetReleaseHistoryResponse{} }
func (m *GetReleaseHistoryResponse) String() string            { return proto.CompactTextString(m) }
func (*GetReleaseHistoryResponse) ProtoMessage()               {}
func (*GetReleaseHistoryResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *GetReleaseHistoryResponse) GetReleases() []*Release {
	if m != nil {
		return m.Releases
	}
	return nil
}

// TestReleaseRequest is a request to get the status of a release.
type TestReleaseRequest struct {
	// Name is the name of the release
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// timeout specifies the max amount of time any kubernetes client command can run.
	Timeout int64 `protobuf:"varint,2,opt,name=timeout" json:"timeout,omitempty"`
	// cleanup specifies whether or not to attempt pod deletion after test completes
	Cleanup   bool   `protobuf:"varint,3,opt,name=cleanup" json:"cleanup,omitempty"`
	Namespace string `protobuf:"bytes,4,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *TestReleaseRequest) Reset()                    { *m = TestReleaseRequest{} }
func (m *TestReleaseRequest) String() string            { return proto.CompactTextString(m) }
func (*TestReleaseRequest) ProtoMessage()               {}
func (*TestReleaseRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *TestReleaseRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TestReleaseRequest) GetTimeout() int64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *TestReleaseRequest) GetCleanup() bool {
	if m != nil {
		return m.Cleanup
	}
	return false
}

func (m *TestReleaseRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

// TestReleaseResponse represents a message from executing a test
type TestReleaseResponse struct {
	Msg    string                      `protobuf:"bytes,1,opt,name=msg" json:"msg,omitempty"`
	Status hapi_release.TestRun_Status `protobuf:"varint,2,opt,name=status,enum=hapi.release.TestRun_Status" json:"status,omitempty"`
}

func (m *TestReleaseResponse) Reset()                    { *m = TestReleaseResponse{} }
func (m *TestReleaseResponse) String() string            { return proto.CompactTextString(m) }
func (*TestReleaseResponse) ProtoMessage()               {}
func (*TestReleaseResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *TestReleaseResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *TestReleaseResponse) GetStatus() hapi_release.TestRun_Status {
	if m != nil {
		return m.Status
	}
	return hapi_release.TestRun_UNKNOWN
}

func init() {
	proto.RegisterType((*Status)(nil), "compass.Status")
	proto.RegisterType((*Info)(nil), "compass.Info")
	proto.RegisterType((*Release)(nil), "compass.Release")
	proto.RegisterType((*CreateReleaseRequest)(nil), "compass.CreateReleaseRequest")
	proto.RegisterType((*CreateReleaseResponse)(nil), "compass.CreateReleaseResponse")
	proto.RegisterType((*UpdateReleaseRequest)(nil), "compass.UpdateReleaseRequest")
	proto.RegisterType((*UpdateReleaseResponse)(nil), "compass.UpdateReleaseResponse")
	proto.RegisterType((*UpgradeReleaseRequest)(nil), "compass.UpgradeReleaseRequest")
	proto.RegisterType((*UpgradeReleaseResponse)(nil), "compass.UpgradeReleaseResponse")
	proto.RegisterType((*ListReleasesRequest)(nil), "compass.ListReleasesRequest")
	proto.RegisterType((*ListSort)(nil), "compass.ListSort")
	proto.RegisterType((*ListReleasesResponse)(nil), "compass.ListReleasesResponse")
	proto.RegisterType((*GetReleaseStatusRequest)(nil), "compass.GetReleaseStatusRequest")
	proto.RegisterType((*GetReleaseStatusResponse)(nil), "compass.GetReleaseStatusResponse")
	proto.RegisterType((*GetReleaseContentRequest)(nil), "compass.GetReleaseContentRequest")
	proto.RegisterType((*GetReleaseContentResponse)(nil), "compass.GetReleaseContentResponse")
	proto.RegisterType((*RollbackReleaseRequest)(nil), "compass.RollbackReleaseRequest")
	proto.RegisterType((*RollbackReleaseResponse)(nil), "compass.RollbackReleaseResponse")
	proto.RegisterType((*DeleteReleaseRequest)(nil), "compass.DeleteReleaseRequest")
	proto.RegisterType((*DeleteReleaseResponse)(nil), "compass.DeleteReleaseResponse")
	proto.RegisterType((*GetReleaseHistoryRequest)(nil), "compass.GetReleaseHistoryRequest")
	proto.RegisterType((*GetReleaseHistoryResponse)(nil), "compass.GetReleaseHistoryResponse")
	proto.RegisterType((*TestReleaseRequest)(nil), "compass.TestReleaseRequest")
	proto.RegisterType((*TestReleaseResponse)(nil), "compass.TestReleaseResponse")
	proto.RegisterEnum("compass.ListSort_SortBy", ListSort_SortBy_name, ListSort_SortBy_value)
	proto.RegisterEnum("compass.ListSort_SortOrder", ListSort_SortOrder_name, ListSort_SortOrder_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for CompassService service

type CompassServiceClient interface {
	CreateRelease(ctx context.Context, in *CreateReleaseRequest, opts ...grpc.CallOption) (*CreateReleaseResponse, error)
	DeleteRelease(ctx context.Context, in *DeleteReleaseRequest, opts ...grpc.CallOption) (*DeleteReleaseResponse, error)
	UpdateRelease(ctx context.Context, in *UpdateReleaseRequest, opts ...grpc.CallOption) (*UpdateReleaseResponse, error)
	UpgradeRelease(ctx context.Context, in *UpgradeReleaseRequest, opts ...grpc.CallOption) (*UpgradeReleaseResponse, error)
	// call the api like this
	// get /v1/namespaces/NAMESPACE/releases?limit=10&offset=denis
	ListReleases(ctx context.Context, in *ListReleasesRequest, opts ...grpc.CallOption) (*ListReleasesResponse, error)
	GetReleaseStatus(ctx context.Context, in *GetReleaseStatusRequest, opts ...grpc.CallOption) (*GetReleaseStatusResponse, error)
	GetReleaseContent(ctx context.Context, in *GetReleaseContentRequest, opts ...grpc.CallOption) (*GetReleaseContentResponse, error)
	GetReleaseHistory(ctx context.Context, in *GetReleaseHistoryRequest, opts ...grpc.CallOption) (*GetReleaseHistoryResponse, error)
	RollbackRelease(ctx context.Context, in *RollbackReleaseRequest, opts ...grpc.CallOption) (*RollbackReleaseResponse, error)
	RunReleaseTest(ctx context.Context, in *TestReleaseRequest, opts ...grpc.CallOption) (CompassService_RunReleaseTestClient, error)
}

type compassServiceClient struct {
	cc *grpc.ClientConn
}

func NewCompassServiceClient(cc *grpc.ClientConn) CompassServiceClient {
	return &compassServiceClient{cc}
}

func (c *compassServiceClient) CreateRelease(ctx context.Context, in *CreateReleaseRequest, opts ...grpc.CallOption) (*CreateReleaseResponse, error) {
	out := new(CreateReleaseResponse)
	err := grpc.Invoke(ctx, "/compass.CompassService/CreateRelease", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *compassServiceClient) DeleteRelease(ctx context.Context, in *DeleteReleaseRequest, opts ...grpc.CallOption) (*DeleteReleaseResponse, error) {
	out := new(DeleteReleaseResponse)
	err := grpc.Invoke(ctx, "/compass.CompassService/DeleteRelease", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *compassServiceClient) UpdateRelease(ctx context.Context, in *UpdateReleaseRequest, opts ...grpc.CallOption) (*UpdateReleaseResponse, error) {
	out := new(UpdateReleaseResponse)
	err := grpc.Invoke(ctx, "/compass.CompassService/UpdateRelease", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *compassServiceClient) UpgradeRelease(ctx context.Context, in *UpgradeReleaseRequest, opts ...grpc.CallOption) (*UpgradeReleaseResponse, error) {
	out := new(UpgradeReleaseResponse)
	err := grpc.Invoke(ctx, "/compass.CompassService/UpgradeRelease", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *compassServiceClient) ListReleases(ctx context.Context, in *ListReleasesRequest, opts ...grpc.CallOption) (*ListReleasesResponse, error) {
	out := new(ListReleasesResponse)
	err := grpc.Invoke(ctx, "/compass.CompassService/ListReleases", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *compassServiceClient) GetReleaseStatus(ctx context.Context, in *GetReleaseStatusRequest, opts ...grpc.CallOption) (*GetReleaseStatusResponse, error) {
	out := new(GetReleaseStatusResponse)
	err := grpc.Invoke(ctx, "/compass.CompassService/GetReleaseStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *compassServiceClient) GetReleaseContent(ctx context.Context, in *GetReleaseContentRequest, opts ...grpc.CallOption) (*GetReleaseContentResponse, error) {
	out := new(GetReleaseContentResponse)
	err := grpc.Invoke(ctx, "/compass.CompassService/GetReleaseContent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *compassServiceClient) GetReleaseHistory(ctx context.Context, in *GetReleaseHistoryRequest, opts ...grpc.CallOption) (*GetReleaseHistoryResponse, error) {
	out := new(GetReleaseHistoryResponse)
	err := grpc.Invoke(ctx, "/compass.CompassService/GetReleaseHistory", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *compassServiceClient) RollbackRelease(ctx context.Context, in *RollbackReleaseRequest, opts ...grpc.CallOption) (*RollbackReleaseResponse, error) {
	out := new(RollbackReleaseResponse)
	err := grpc.Invoke(ctx, "/compass.CompassService/RollbackRelease", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *compassServiceClient) RunReleaseTest(ctx context.Context, in *TestReleaseRequest, opts ...grpc.CallOption) (CompassService_RunReleaseTestClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CompassService_serviceDesc.Streams[0], c.cc, "/compass.CompassService/RunReleaseTest", opts...)
	if err != nil {
		return nil, err
	}
	x := &compassServiceRunReleaseTestClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CompassService_RunReleaseTestClient interface {
	Recv() (*TestReleaseResponse, error)
	grpc.ClientStream
}

type compassServiceRunReleaseTestClient struct {
	grpc.ClientStream
}

func (x *compassServiceRunReleaseTestClient) Recv() (*TestReleaseResponse, error) {
	m := new(TestReleaseResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for CompassService service

type CompassServiceServer interface {
	CreateRelease(context.Context, *CreateReleaseRequest) (*CreateReleaseResponse, error)
	DeleteRelease(context.Context, *DeleteReleaseRequest) (*DeleteReleaseResponse, error)
	UpdateRelease(context.Context, *UpdateReleaseRequest) (*UpdateReleaseResponse, error)
	UpgradeRelease(context.Context, *UpgradeReleaseRequest) (*UpgradeReleaseResponse, error)
	// call the api like this
	// get /v1/namespaces/NAMESPACE/releases?limit=10&offset=denis
	ListReleases(context.Context, *ListReleasesRequest) (*ListReleasesResponse, error)
	GetReleaseStatus(context.Context, *GetReleaseStatusRequest) (*GetReleaseStatusResponse, error)
	GetReleaseContent(context.Context, *GetReleaseContentRequest) (*GetReleaseContentResponse, error)
	GetReleaseHistory(context.Context, *GetReleaseHistoryRequest) (*GetReleaseHistoryResponse, error)
	RollbackRelease(context.Context, *RollbackReleaseRequest) (*RollbackReleaseResponse, error)
	RunReleaseTest(*TestReleaseRequest, CompassService_RunReleaseTestServer) error
}

func RegisterCompassServiceServer(s *grpc.Server, srv CompassServiceServer) {
	s.RegisterService(&_CompassService_serviceDesc, srv)
}

func _CompassService_CreateRelease_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateReleaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompassServiceServer).CreateRelease(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/compass.CompassService/CreateRelease",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompassServiceServer).CreateRelease(ctx, req.(*CreateReleaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CompassService_DeleteRelease_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteReleaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompassServiceServer).DeleteRelease(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/compass.CompassService/DeleteRelease",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompassServiceServer).DeleteRelease(ctx, req.(*DeleteReleaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CompassService_UpdateRelease_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateReleaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompassServiceServer).UpdateRelease(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/compass.CompassService/UpdateRelease",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompassServiceServer).UpdateRelease(ctx, req.(*UpdateReleaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CompassService_UpgradeRelease_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpgradeReleaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompassServiceServer).UpgradeRelease(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/compass.CompassService/UpgradeRelease",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompassServiceServer).UpgradeRelease(ctx, req.(*UpgradeReleaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CompassService_ListReleases_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReleasesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompassServiceServer).ListReleases(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/compass.CompassService/ListReleases",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompassServiceServer).ListReleases(ctx, req.(*ListReleasesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CompassService_GetReleaseStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReleaseStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompassServiceServer).GetReleaseStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/compass.CompassService/GetReleaseStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompassServiceServer).GetReleaseStatus(ctx, req.(*GetReleaseStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CompassService_GetReleaseContent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReleaseContentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompassServiceServer).GetReleaseContent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/compass.CompassService/GetReleaseContent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompassServiceServer).GetReleaseContent(ctx, req.(*GetReleaseContentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CompassService_GetReleaseHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReleaseHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompassServiceServer).GetReleaseHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/compass.CompassService/GetReleaseHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompassServiceServer).GetReleaseHistory(ctx, req.(*GetReleaseHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CompassService_RollbackRelease_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RollbackReleaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompassServiceServer).RollbackRelease(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/compass.CompassService/RollbackRelease",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompassServiceServer).RollbackRelease(ctx, req.(*RollbackReleaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CompassService_RunReleaseTest_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TestReleaseRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CompassServiceServer).RunReleaseTest(m, &compassServiceRunReleaseTestServer{stream})
}

type CompassService_RunReleaseTestServer interface {
	Send(*TestReleaseResponse) error
	grpc.ServerStream
}

type compassServiceRunReleaseTestServer struct {
	grpc.ServerStream
}

func (x *compassServiceRunReleaseTestServer) Send(m *TestReleaseResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _CompassService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "compass.CompassService",
	HandlerType: (*CompassServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateRelease",
			Handler:    _CompassService_CreateRelease_Handler,
		},
		{
			MethodName: "DeleteRelease",
			Handler:    _CompassService_DeleteRelease_Handler,
		},
		{
			MethodName: "UpdateRelease",
			Handler:    _CompassService_UpdateRelease_Handler,
		},
		{
			MethodName: "UpgradeRelease",
			Handler:    _CompassService_UpgradeRelease_Handler,
		},
		{
			MethodName: "ListReleases",
			Handler:    _CompassService_ListReleases_Handler,
		},
		{
			MethodName: "GetReleaseStatus",
			Handler:    _CompassService_GetReleaseStatus_Handler,
		},
		{
			MethodName: "GetReleaseContent",
			Handler:    _CompassService_GetReleaseContent_Handler,
		},
		{
			MethodName: "GetReleaseHistory",
			Handler:    _CompassService_GetReleaseHistory_Handler,
		},
		{
			MethodName: "RollbackRelease",
			Handler:    _CompassService_RollbackRelease_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RunReleaseTest",
			Handler:       _CompassService_RunReleaseTest_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "compass.proto",
}

func init() { proto.RegisterFile("compass.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1363 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0xdf, 0x6e, 0x13, 0xc7,
	0x17, 0xfe, 0x8d, 0xff, 0xfb, 0x18, 0x07, 0x33, 0x84, 0xc4, 0x3f, 0x13, 0x68, 0x58, 0x84, 0x40,
	0x29, 0x8a, 0xc1, 0x40, 0xd5, 0x52, 0x54, 0x29, 0xd8, 0x29, 0xa0, 0xd2, 0x20, 0xad, 0x41, 0x48,
	0x95, 0x4a, 0xb4, 0xac, 0xc7, 0xc9, 0x8a, 0xcd, 0x8e, 0xbb, 0x33, 0x9b, 0x26, 0x45, 0xdc, 0x44,
	0xad, 0x7a, 0xd1, 0x8a, 0x8b, 0x56, 0xaa, 0xaa, 0x4a, 0xbd, 0xec, 0x33, 0xb4, 0x2f, 0xd1, 0xab,
	0xbe, 0x42, 0x1f, 0xa4, 0x9a, 0x3f, 0xbb, 0xd9, 0x5d, 0x6f, 0x9c, 0xd8, 0x6a, 0x6f, 0x92, 0x3d,
	0x73, 0x8e, 0x7d, 0xbe, 0xef, 0x3b, 0x67, 0xcf, 0x9c, 0x04, 0xea, 0x36, 0xdd, 0x19, 0x59, 0x8c,
	0xad, 0x8e, 0x7c, 0xca, 0x29, 0x2e, 0x6b, 0xb3, 0x75, 0x7e, 0xdb, 0x1a, 0x39, 0x6d, 0x9f, 0xb8,
	0xc4, 0x62, 0xa4, 0xcd, 0x09, 0xe3, 0x9b, 0x7e, 0xe0, 0xa9, 0xa8, 0xd6, 0x85, 0x71, 0x27, 0x0b,
	0x1c, 0x4e, 0xb4, 0x7b, 0x51, 0xba, 0xed, 0x6d, 0xcb, 0xe7, 0x6d, 0x9b, 0x7a, 0x43, 0x67, 0x4b,
	0x3b, 0x16, 0xe2, 0x0e, 0xf1, 0x53, 0x9f, 0x2f, 0x6d, 0x51, 0xba, 0xe5, 0x92, 0xb6, 0xf0, 0x5a,
	0x9e, 0x47, 0xb9, 0xc5, 0x1d, 0xea, 0x69, 0x4c, 0xc6, 0xcf, 0x08, 0x4a, 0x7d, 0x6e, 0xf1, 0x80,
	0x61, 0x0c, 0x05, 0x9b, 0x0e, 0x48, 0x13, 0x2d, 0xa3, 0x6b, 0x45, 0x53, 0x3e, 0xe3, 0x25, 0xa8,
	0xfa, 0x84, 0xd1, 0xc0, 0xb7, 0x09, 0x6b, 0xe6, 0x96, 0xd1, 0xb5, 0xaa, 0x79, 0x78, 0x80, 0xe7,
	0xa1, 0xe8, 0x51, 0x4e, 0x58, 0x33, 0x2f, 0x3d, 0xca, 0xc0, 0x1f, 0xc3, 0x59, 0xd7, 0x62, 0x7c,
	0xf3, 0x10, 0xba, 0x60, 0xd7, 0x2c, 0x2c, 0xa3, 0x6b, 0xb5, 0xce, 0xe2, 0xaa, 0x80, 0xb9, 0xaa,
	0xe9, 0xad, 0x3e, 0x25, 0x8c, 0xf7, 0x45, 0x88, 0xd9, 0x10, 0x9f, 0x39, 0x34, 0x03, 0xcf, 0xf8,
	0x1d, 0x41, 0xe1, 0x91, 0x37, 0xa4, 0xf8, 0x2a, 0x94, 0x98, 0x84, 0x28, 0xa1, 0xd5, 0x3a, 0xa7,
	0x57, 0x43, 0x5d, 0x15, 0x72, 0x53, 0xbb, 0xf1, 0x15, 0x98, 0x1b, 0x3a, 0x3e, 0xe3, 0x9b, 0x03,
	0x32, 0x72, 0xe9, 0x3e, 0x19, 0x48, 0xc8, 0x79, 0xb3, 0x2e, 0x4f, 0x7b, 0xfa, 0x10, 0x5f, 0x86,
	0xba, 0x04, 0x18, 0x45, 0xe5, 0x65, 0xd4, 0x29, 0x71, 0x18, 0x05, 0x35, 0xa1, 0x3c, 0x20, 0x2e,
	0xe1, 0x64, 0x20, 0x91, 0xe7, 0xcd, 0xd0, 0xc4, 0xcb, 0x50, 0xeb, 0x11, 0x66, 0xfb, 0xce, 0x48,
	0x08, 0xd9, 0x2c, 0x4a, 0xee, 0xf1, 0x23, 0xe3, 0x4f, 0x04, 0x65, 0x53, 0x31, 0x14, 0xaa, 0x7a,
	0xd6, 0x8e, 0x52, 0xb5, 0x6a, 0xca, 0x67, 0x7c, 0x09, 0x0a, 0x8e, 0x37, 0xa4, 0x12, 0x5d, 0xad,
	0x53, 0x8f, 0xe8, 0x08, 0xb6, 0xa6, 0x74, 0xe1, 0xab, 0x50, 0x94, 0x45, 0x94, 0xd8, 0x6a, 0x9d,
	0x33, 0x4a, 0x36, 0x55, 0xd7, 0xae, 0xf8, 0x69, 0x2a, 0x3f, 0x5e, 0x81, 0x92, 0x6a, 0x03, 0x2d,
	0x30, 0x4e, 0x44, 0x4a, 0x8f, 0xa9, 0x23, 0x04, 0xa7, 0x5d, 0xe2, 0xb3, 0x10, 0x75, 0xd1, 0x0c,
	0x4d, 0x51, 0x67, 0x81, 0x8c, 0x8d, 0x2c, 0x9b, 0x34, 0x4b, 0xaa, 0xce, 0xd1, 0x81, 0xf1, 0x07,
	0x82, 0xf9, 0xae, 0x4f, 0x2c, 0x4e, 0x34, 0x2b, 0x93, 0x7c, 0x11, 0x10, 0xc6, 0x45, 0x03, 0x28,
	0x94, 0x8a, 0x9d, 0x86, 0x14, 0x52, 0xce, 0xc5, 0x28, 0x27, 0x12, 0xe4, 0x53, 0x09, 0x04, 0x89,
	0x5d, 0xcb, 0x0d, 0x08, 0x9b, 0x44, 0x42, 0x45, 0x08, 0x12, 0xdc, 0xd9, 0x21, 0x34, 0xe0, 0x92,
	0x44, 0xde, 0x0c, 0x4d, 0x91, 0xf7, 0x4b, 0xcb, 0xe1, 0x12, 0x7f, 0xc5, 0x94, 0xcf, 0x46, 0x17,
	0xce, 0xa5, 0x90, 0xb3, 0x11, 0xf5, 0x98, 0x48, 0x59, 0xd6, 0x4d, 0xa8, 0xbb, 0xaa, 0x11, 0x95,
	0x21, 0x0c, 0x0d, 0x03, 0x8c, 0xb7, 0x08, 0xe6, 0x9f, 0x8d, 0x06, 0xe3, 0xfc, 0xb3, 0x8a, 0x1b,
	0x13, 0x39, 0x97, 0x14, 0xf9, 0x90, 0x65, 0xfe, 0x58, 0x96, 0x09, 0xbd, 0x0a, 0xe9, 0x82, 0x74,
	0xe1, 0x5c, 0x0a, 0xcf, 0x0c, 0xac, 0xbe, 0x43, 0xe2, 0x5b, 0xb6, 0x7c, 0x6b, 0x30, 0x7b, 0x59,
	0xff, 0x3d, 0x4a, 0x3d, 0x58, 0x48, 0x83, 0x99, 0x81, 0x93, 0x05, 0x67, 0x1f, 0x3b, 0x8c, 0xeb,
	0x73, 0x16, 0x23, 0xe4, 0x3a, 0x3b, 0x8e, 0x22, 0x94, 0x37, 0x95, 0x81, 0x17, 0xa0, 0x44, 0x87,
	0x43, 0x46, 0xb8, 0xa6, 0xa4, 0xad, 0xc9, 0xbd, 0x6a, 0xbc, 0x80, 0x8a, 0x48, 0xd1, 0xa7, 0x3e,
	0x37, 0x3a, 0x50, 0x12, 0xbf, 0xef, 0xef, 0xe3, 0x1a, 0x94, 0x9f, 0x6d, 0x7c, 0xb2, 0xf1, 0xe4,
	0xf9, 0x46, 0xe3, 0x7f, 0xb8, 0x02, 0x85, 0x8d, 0xb5, 0x4f, 0xd7, 0x1b, 0x08, 0x9f, 0x81, 0xfa,
	0xe3, 0xb5, 0xfe, 0xd3, 0x4d, 0x73, 0xfd, 0xf1, 0xfa, 0x5a, 0x7f, 0xbd, 0xd7, 0xc8, 0x19, 0x17,
	0xa1, 0x2a, 0x3e, 0xf3, 0xc4, 0x1f, 0x10, 0x1f, 0x97, 0x21, 0xbf, 0xd6, 0xef, 0xaa, 0x8f, 0xf4,
	0xd6, 0xfb, 0xdd, 0x06, 0x32, 0xbe, 0x46, 0x30, 0x9f, 0xe4, 0xa0, 0x75, 0x10, 0x55, 0xa1, 0x81,
	0x17, 0x91, 0x90, 0x86, 0xac, 0x0a, 0xd9, 0xe3, 0x51, 0x55, 0xc8, 0x9e, 0xa4, 0xcb, 0x29, 0xb7,
	0x5c, 0x3d, 0xd8, 0x94, 0x81, 0xaf, 0x43, 0x45, 0xcb, 0x24, 0x5e, 0xb3, 0x7c, 0xa6, 0x90, 0x51,
	0x84, 0x41, 0x60, 0xf1, 0x01, 0x09, 0x41, 0xe8, 0x39, 0x3b, 0x53, 0xd7, 0x4f, 0x56, 0x93, 0x42,
	0x73, 0x3c, 0x8d, 0x26, 0x3c, 0xe3, 0xe8, 0x9c, 0x9c, 0x70, 0x18, 0x4f, 0xd8, 0xa5, 0x1e, 0x27,
	0x1e, 0xff, 0x2f, 0x88, 0x3d, 0x80, 0xff, 0x67, 0xe4, 0x99, 0xa1, 0xa5, 0x0f, 0x72, 0xb0, 0x60,
	0x52, 0xd7, 0x7d, 0x69, 0xd9, 0xaf, 0x4e, 0x30, 0x7e, 0x16, 0xa1, 0x3c, 0xf0, 0xf7, 0xe5, 0x8d,
	0x9b, 0x93, 0x73, 0xb0, 0x34, 0xf0, 0xf7, 0xcd, 0xc0, 0x13, 0xb7, 0xde, 0xc0, 0x61, 0xd6, 0x4b,
	0x97, 0x6c, 0x6e, 0x53, 0xfa, 0x4a, 0xbd, 0xb1, 0x15, 0xf3, 0x94, 0x3e, 0x7c, 0x28, 0xce, 0xe2,
	0x6c, 0x0b, 0x49, 0xb6, 0x2d, 0xd1, 0x3d, 0xb6, 0x1c, 0xa5, 0x72, 0xee, 0x56, 0xcc, 0xc8, 0x8e,
	0x8f, 0xe4, 0x52, 0xf6, 0x48, 0x2e, 0x1f, 0x8e, 0x64, 0xd1, 0x9d, 0x43, 0xea, 0xdb, 0xa4, 0x59,
	0x91, 0x87, 0xca, 0x48, 0xaa, 0x59, 0x4d, 0xab, 0xb9, 0x0e, 0x8b, 0x63, 0x1a, 0xcc, 0xa0, 0xe5,
	0xaf, 0x08, 0xe6, 0x7b, 0xf2, 0x1a, 0x3f, 0x81, 0x92, 0x63, 0x82, 0xe5, 0x32, 0x04, 0x9b, 0x87,
	0xe2, 0x28, 0xf0, 0xb7, 0x88, 0x56, 0x53, 0x19, 0x71, 0x41, 0x0a, 0x49, 0x41, 0x12, 0x34, 0x8b,
	0x69, 0x9a, 0xcf, 0xe1, 0x5c, 0x0a, 0xde, 0xf4, 0x24, 0x05, 0x97, 0xe8, 0x15, 0xa9, 0xaa, 0x77,
	0xc2, 0x78, 0x11, 0xef, 0xfa, 0x87, 0x0e, 0xe3, 0xd4, 0xdf, 0x9f, 0xc4, 0xbd, 0x01, 0xf9, 0x1d,
	0x6b, 0x4f, 0x77, 0xbc, 0x78, 0x3c, 0xa6, 0xdb, 0x1f, 0xc5, 0xbb, 0x3d, 0xfa, 0x7e, 0x0d, 0x3e,
	0x3e, 0x78, 0xd0, 0xb1, 0x83, 0xe7, 0x2b, 0xc0, 0x62, 0x0d, 0x3c, 0xd9, 0x4d, 0x1b, 0xaa, 0x9c,
	0x4b, 0xaa, 0xdc, 0x84, 0xb2, 0xed, 0x12, 0xcb, 0x0b, 0x46, 0xba, 0x2e, 0xa1, 0x79, 0xcc, 0x25,
	0xf4, 0x39, 0x9c, 0x4d, 0xe4, 0xd6, 0x04, 0x84, 0x1a, 0x6c, 0x4b, 0xe7, 0x16, 0x8f, 0xf8, 0x76,
	0xb4, 0x92, 0x8a, 0xcc, 0x73, 0x9d, 0xa5, 0xf1, 0xb5, 0xd6, 0x0c, 0xbc, 0xd4, 0x7e, 0xda, 0xf9,
	0xad, 0x06, 0x73, 0x5d, 0x45, 0xbc, 0x4f, 0xfc, 0x5d, 0xc7, 0x26, 0xf8, 0x1b, 0x04, 0xf5, 0xc4,
	0x82, 0x82, 0x2f, 0x44, 0xda, 0x64, 0xad, 0x5c, 0xad, 0x8b, 0x47, 0xb9, 0x15, 0x56, 0xe3, 0xce,
	0xc1, 0x5f, 0x7f, 0xff, 0x98, 0x6b, 0x1b, 0x2b, 0xed, 0xdd, 0x9b, 0xed, 0x88, 0x19, 0x6b, 0xbf,
	0x8e, 0x9e, 0xdf, 0x84, 0x7f, 0x5c, 0xe8, 0xc3, 0x37, 0x77, 0xd1, 0x0a, 0x3e, 0x40, 0x50, 0x4f,
	0xb4, 0x5e, 0x0c, 0x47, 0xd6, 0x1b, 0x13, 0xc3, 0x91, 0xd9, 0xb1, 0x46, 0x47, 0xe2, 0xb8, 0xbe,
	0x32, 0x05, 0x0e, 0xfc, 0x3d, 0x82, 0x7a, 0x62, 0xaf, 0x89, 0x81, 0xc8, 0xda, 0xbf, 0x62, 0x20,
	0x32, 0xd7, 0x21, 0xe3, 0x9e, 0x04, 0xf1, 0x5e, 0xeb, 0xe6, 0xc9, 0x41, 0xb4, 0xd5, 0xb6, 0x22,
	0x34, 0x79, 0x8b, 0x60, 0x2e, 0xb9, 0x93, 0xe0, 0x78, 0xc2, 0x8c, 0xcd, 0xa9, 0xf5, 0xce, 0x91,
	0x7e, 0x8d, 0xe8, 0x43, 0x89, 0xe8, 0x4e, 0xeb, 0xc6, 0x14, 0x88, 0xe4, 0x36, 0x25, 0x00, 0xed,
	0xc1, 0xa9, 0xf8, 0x66, 0x80, 0x97, 0xa2, 0x6c, 0x19, 0x4b, 0x4f, 0xeb, 0xc2, 0x11, 0x5e, 0x8d,
	0xe4, 0x5d, 0x89, 0xe4, 0x0a, 0xbe, 0x7c, 0x02, 0x24, 0xf8, 0x07, 0x04, 0x8d, 0xf4, 0x3d, 0x8d,
	0x97, 0xa3, 0x04, 0x47, 0x6c, 0x0a, 0xad, 0x4b, 0x13, 0x22, 0x34, 0x8c, 0x0f, 0x24, 0x8c, 0x5b,
	0x78, 0x9a, 0x12, 0xe9, 0x3f, 0xf7, 0x7e, 0x42, 0x70, 0x66, 0xec, 0x8e, 0xc5, 0x59, 0x39, 0x93,
	0xf7, 0x7c, 0xcb, 0x98, 0x14, 0xa2, 0x71, 0xdd, 0x95, 0xb8, 0x6e, 0xe3, 0xce, 0x34, 0x85, 0xd2,
	0x10, 0x92, 0xc0, 0xf4, 0x38, 0xcc, 0x04, 0x96, 0x1c, 0xc5, 0x99, 0xc0, 0x52, 0xd3, 0x74, 0x26,
	0x60, 0xdb, 0x1a, 0xc2, 0x2f, 0x08, 0x4e, 0xa7, 0xee, 0x51, 0x7c, 0xd8, 0xb2, 0xd9, 0x5b, 0x46,
	0x6b, 0xf9, 0xe8, 0x00, 0x0d, 0xa9, 0x27, 0x21, 0x7d, 0x64, 0xdc, 0x9b, 0xe6, 0x35, 0x53, 0x7b,
	0x45, 0xfb, 0xb5, 0x7e, 0x78, 0x83, 0xbf, 0x45, 0x30, 0x67, 0x06, 0x9e, 0xfe, 0x72, 0x31, 0x42,
	0xf1, 0xf9, 0x28, 0xf5, 0xf8, 0x95, 0xd0, 0x5a, 0xca, 0x76, 0x6a, 0x4c, 0xef, 0x4b, 0x4c, 0x1d,
	0x63, 0x9a, 0x17, 0x8d, 0x13, 0xc6, 0xd9, 0x0d, 0x74, 0xbf, 0xfa, 0x59, 0xf8, 0xaf, 0x9a, 0x97,
	0x25, 0xf9, 0x6f, 0x92, 0x5b, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0x4a, 0xf8, 0x39, 0xb8, 0xcb,
	0x11, 0x00, 0x00,
}
